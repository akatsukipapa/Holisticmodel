<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VTuber Complete Edition - Full Body & Hand Tracking</title>
    <style>
      body {
        margin: 0;
        background-color: #222;
        overflow: hidden;
        font-family: monospace;
      }
      .container {
        position: relative;
        width: 100vw;
        height: 100vh;
      }
      /* „Ç´„É°„É©Êò†ÂÉèÔºö„Éà„Ç∞„É´ÂèØËÉΩ */
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        object-fit: cover;
        z-index: 0;
        transition: opacity 0.3s ease;
      }
      canvas#skeleton-canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        transform: scaleX(-1);
        z-index: 1;
        pointer-events: none;
      }
      /* Êìç‰Ωú„Ç¨„Ç§„Éâ */
      #controls {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 220px;
        background: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 12px;
        border-radius: 10px;
        z-index: 1000;
        font-size: 11px;
        pointer-events: none;
        line-height: 1.6;
        border: 1px solid rgba(255, 255, 255, 0.3);
        backdrop-filter: blur(5px);
      }
      .key {
        display: inline-block;
        background: #555;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
        border: 1px solid #888;
        min-width: 18px;
        text-align: center;
      }
      .section-title {
        color: #00ffcc;
        font-weight: bold;
        margin-top: 8px;
        margin-bottom: 4px;
      }
      .section-title:first-child {
        margin-top: 0;
      }
      /* „Çπ„ÉÜ„Éº„Çø„Çπ */
      #status-panel {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 8px 12px;
        border-radius: 10px;
        z-index: 1000;
        font-size: 12px;
        pointer-events: none;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      .ok {
        color: #00ff00;
      }
      .tracking {
        color: #ffcc00;
      }
      /* „Éú„Çø„É≥Áæ§ */
      .btn-container {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        z-index: 100;
      }
      .action-btn {
        padding: 12px 30px;
        font-size: 1.1rem;
        font-weight: bold;
        color: #888;
        background: #333;
        border: 2px solid #555;
        border-radius: 50px;
        cursor: not-allowed;
        transition: all 0.3s;
      }
      .action-btn.ready {
        color: #fff;
        background: linear-gradient(45deg, #ff00cc, #3333ff);
        border: none;
        cursor: pointer;
        box-shadow: 0 0 20px rgba(255, 0, 204, 0.5);
      }
      .action-btn.ready:hover {
        box-shadow: 0 0 30px rgba(255, 0, 204, 0.8);
        transform: scale(1.05);
      }
      .action-btn.bg-toggle {
        background: linear-gradient(45deg, #00ccff, #0066ff);
        box-shadow: 0 0 20px rgba(0, 204, 255, 0.5);
      }
      .action-btn.bg-toggle:hover {
        box-shadow: 0 0 30px rgba(0, 204, 255, 0.8);
      }
      .action-btn.bg-off {
        background: linear-gradient(45deg, #666, #444);
        box-shadow: 0 0 10px rgba(100, 100, 100, 0.5);
      }
    </style>
  </head>
  <body>
    <div id="status-panel">
      VRM: <span id="st-vrm" style="color: red">Loading...</span><br />
      ËÉåÊôØ: <span id="st-bg" class="ok">ON</span>
    </div>
    <!-- Êìç‰Ωú„Ç¨„Ç§„Éâ -->
    <div id="controls">
      <div class="section-title">üìç ‰ΩçÁΩÆË™øÊï¥ (Position)</div>
      <span class="key">‚Üë</span> <span class="key">‚Üì</span> : ‰∏ä‰∏ãÁßªÂãï<br />
      <span class="key">‚Üê</span> <span class="key">‚Üí</span> : Â∑¶Âè≥ÁßªÂãï<br />
      <span class="key">W</span> : „Ç∫„Éº„É†„Ç§„É≥<br />
      <span class="key">S</span> : „Ç∫„Éº„É†„Ç¢„Ç¶„Éà<br />
      <span class="key">R</span> : ‰ΩçÁΩÆ„É™„Çª„ÉÉ„Éà<br />
      <div class="section-title">üé¨ Ë°®Á§∫ÂàáÊõø (Display)</div>
      <span class="key">B</span> : ËÉåÊôØ„Ç´„É°„É© ON/OFF<br />
      <div class="section-title">ü¶¥ „Éà„É©„ÉÉ„Ç≠„É≥„Ç∞ÂØæË±°</div>
      È°î„Éª‰Ωì„ÉªËÖï„ÉªË∂≥„ÉªÊåá
    </div>
    <div class="container">
      <video id="input-video" playsinline muted autoplay></video>
      <canvas id="skeleton-canvas"></canvas>
    </div>
    <div class="btn-container">
      <button id="toggle-btn" class="action-btn" disabled>
        Loading Model...
      </button>
      <button id="bg-btn" class="action-btn ready bg-toggle">ËÉåÊôØ ON</button>
    </div>
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/@pixiv/three-vrm@1.0.0/lib/three-vrm.min.js"></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"
      crossorigin="anonymous"
    ></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>
    <script>
      // ============================================================
      //  VTuber Complete Edition
      //  - Face, Body, Legs, Hands (Fingers) Full Tracking
      //  - Background Camera Toggle (B key or Button)
      // ============================================================
      const videoElement = document.getElementById("input-video");
      const skeletonCanvas = document.getElementById("skeleton-canvas");
      const skelCtx = skeletonCanvas.getContext("2d");
      const toggleBtn = document.getElementById("toggle-btn");
      const bgBtn = document.getElementById("bg-btn");
      const stVrm = document.getElementById("st-vrm");
      const stBg = document.getElementById("st-bg");
      const VRM_FILE_PATH = "./avatar.vrm";
      let currentVrm = null;
      let isAvatarMode = false;
      let isBgVisible = true; // ËÉåÊôØ„Ç´„É°„É©Ë°®Á§∫Áä∂ÊÖã
      // --- 1. Three.js Setup ---
      const renderer = new THREE.WebGLRenderer({
        alpha: true,
        antialias: true,
      });
      renderer.domElement.id = "avatar-canvas";
      renderer.domElement.style.cssText =
        "position:absolute; top:0; left:0; width:100%; height:100%; z-index:2; display:none;";
      document.querySelector(".container").appendChild(renderer.domElement);
      const scene = new THREE.Scene();
      // ÂàùÊúü„Ç´„É°„É©‰ΩçÁΩÆ
      const initialPos = { x: 0.0, y: 1.3, z: 2.0 };
      const camera = new THREE.PerspectiveCamera(
        30.0,
        window.innerWidth / window.innerHeight,
        0.1,
        20.0
      );
      camera.position.set(initialPos.x, initialPos.y, initialPos.z);
      scene.add(new THREE.DirectionalLight(0xffffff, 0.8));
      scene.add(new THREE.AmbientLight(0x606060));
      // --- ËÉåÊôØ„Éà„Ç∞„É´Èñ¢Êï∞ ---
      function toggleBackground() {
        isBgVisible = !isBgVisible;
        videoElement.style.opacity = isBgVisible ? "1.0" : "0.0";
        stBg.innerText = isBgVisible ? "ON" : "OFF";
        stBg.className = isBgVisible ? "ok" : "tracking";
        bgBtn.innerText = isBgVisible ? "ËÉåÊôØ ON" : "ËÉåÊôØ OFF";
        bgBtn.classList.toggle("bg-off", !isBgVisible);
        bgBtn.classList.toggle("bg-toggle", isBgVisible);
      }
      // --- „Ç≠„Éº„Éú„Éº„ÉâÊìç‰Ωú ---
      window.addEventListener("keydown", (e) => {
        // B„Ç≠„Éº„ÅØÂ∏∏„Å´ÊúâÂäπÔºàËÉåÊôØ„Éà„Ç∞„É´Ôºâ
        if (e.key === "b" || e.key === "B") {
          toggleBackground();
          return;
        }
        // ‰ª•‰∏ã„ÅØ„Ç¢„Éê„Çø„Éº„É¢„Éº„ÉâÊôÇ„ÅÆ„Åø
        if (!isAvatarMode) return;
        const moveStep = 0.1;
        switch (e.key) {
          case "ArrowUp":
            camera.position.y += moveStep;
            break;
          case "ArrowDown":
            camera.position.y -= moveStep;
            break;
          case "ArrowLeft":
            camera.position.x -= moveStep;
            break;
          case "ArrowRight":
            camera.position.x += moveStep;
            break;
          case "w":
          case "W":
            camera.position.z -= moveStep;
            break;
          case "s":
          case "S":
            camera.position.z += moveStep;
            break;
          case "r":
          case "R":
            camera.position.set(initialPos.x, initialPos.y, initialPos.z);
            break;
        }
      });
      // --- ËÉåÊôØ„Éú„Çø„É≥„ÇØ„É™„ÉÉ„ÇØ ---
      bgBtn.addEventListener("click", toggleBackground);
      function resize() {
        renderer.setSize(window.innerWidth, window.innerHeight);
        skeletonCanvas.width = window.innerWidth;
        skeletonCanvas.height = window.innerHeight;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      }
      window.addEventListener("resize", resize);
      resize();
      // --- 2. VRM Load ---
      new THREE.GLTFLoader()
        .register((p) => new THREE_VRM.VRMLoaderPlugin(p))
        .load(
          VRM_FILE_PATH,
          (gltf) => {
            currentVrm = gltf.userData.vrm;
            scene.add(currentVrm.scene);
            currentVrm.scene.rotation.y = Math.PI;
            currentVrm.scene.position.set(0, 0, 0);
            // T„Éù„Éº„Ç∫Ë£úÊ≠£
            const h = currentVrm.humanoid;
            if (h.getNormalizedBoneNode("leftUpperArm"))
              h.getNormalizedBoneNode("leftUpperArm").rotation.z = 1.2;
            if (h.getNormalizedBoneNode("rightUpperArm"))
              h.getNormalizedBoneNode("rightUpperArm").rotation.z = -1.2;
            stVrm.innerText = "OK (Ready)";
            stVrm.className = "ok";
            toggleBtn.disabled = false;
            toggleBtn.classList.add("ready");
            toggleBtn.innerText = "üé≠ „Ç¢„Éê„Çø„Éº ON";
          },
          undefined,
          (e) => {
            stVrm.innerText = "Error: " + (e.message || "Load Failed");
            console.error("VRM Load Error:", e);
          }
        );
      // --- 3. Toggle Button ---
      toggleBtn.addEventListener("click", () => {
        if (!currentVrm) return;
        isAvatarMode = !isAvatarMode;
        const avatarCanvas = document.getElementById("avatar-canvas");
        if (isAvatarMode) {
          avatarCanvas.style.display = "block";
          skeletonCanvas.style.display = "none";
          toggleBtn.innerText = "ü¶¥ È™®Ê†º„É¢„Éº„Éâ";
        } else {
          avatarCanvas.style.display = "none";
          skeletonCanvas.style.display = "block";
          toggleBtn.innerText = "üé≠ „Ç¢„Éê„Çø„Éº ON";
        }
      });
      // --- 4. Holistic (MediaPipe) Setup ---
      const holistic = new Holistic({
        locateFile: (f) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${f}`,
      });
      holistic.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
        refineFaceLandmarks: true,
      });
      // --- 5. Êåá„Éú„Éº„É≥„Éû„ÉÉ„Éî„É≥„Ç∞Áî®„Éò„É´„Éë„Éº ---
      // VRM 1.0 „ÅÆÊåá„Éú„Éº„É≥Âêç
      const fingerBoneNames = {
        left: {
          thumb: [
            "leftThumbMetacarpal",
            "leftThumbProximal",
            "leftThumbDistal",
          ],
          index: [
            "leftIndexProximal",
            "leftIndexIntermediate",
            "leftIndexDistal",
          ],
          middle: [
            "leftMiddleProximal",
            "leftMiddleIntermediate",
            "leftMiddleDistal",
          ],
          ring: ["leftRingProximal", "leftRingIntermediate", "leftRingDistal"],
          little: [
            "leftLittleProximal",
            "leftLittleIntermediate",
            "leftLittleDistal",
          ],
        },
        right: {
          thumb: [
            "rightThumbMetacarpal",
            "rightThumbProximal",
            "rightThumbDistal",
          ],
          index: [
            "rightIndexProximal",
            "rightIndexIntermediate",
            "rightIndexDistal",
          ],
          middle: [
            "rightMiddleProximal",
            "rightMiddleIntermediate",
            "rightMiddleDistal",
          ],
          ring: [
            "rightRingProximal",
            "rightRingIntermediate",
            "rightRingDistal",
          ],
          little: [
            "rightLittleProximal",
            "rightLittleIntermediate",
            "rightLittleDistal",
          ],
        },
      };
      // Êåá„ÅÆÂõûËª¢„ÇíÈÅ©Áî®„Åô„Çã„Éò„É´„Éë„ÉºÈñ¢Êï∞
      function applyFingerRig(handRig, side) {
        if (!handRig || !currentVrm) return;
        const bones = fingerBoneNames[side];
        const humanoid = currentVrm.humanoid;
        const lerpAmount = 0.3;
        // ÂêÑÊåá„Å´ÂØæ„Åó„Å¶Âá¶ÁêÜ
        Object.keys(bones).forEach((fingerName) => {
          const fingerData =
            handRig[fingerName.charAt(0).toUpperCase() + fingerName.slice(1)];
          if (!fingerData) return;
          const boneList = bones[fingerName];
          // Êåá„ÅÆÊõ≤„ÅíÔºàcurlÔºâ„ÇíÂêÑÈñ¢ÁØÄ„Å´ÈÅ©Áî®
          boneList.forEach((boneName, index) => {
            const node = humanoid.getNormalizedBoneNode(boneName);
            if (!node) return;
            // Ë¶™Êåá„ÅØÁâπÊÆäÂá¶ÁêÜÔºàÊ®™ÊñπÂêë„ÅÆÂãï„Åç„ÇÇÂê´„ÇÄÔºâ
            if (fingerName === "thumb") {
              const curlValue = fingerData.curl || 0;
              const spreadValue = fingerData.spread || 0;
              if (index === 0) {
                // Metacarpal: Èñã„ÅçÂÖ∑Âêà
                const targetRot = new THREE.Euler(
                  0,
                  side === "left" ? spreadValue * 0.5 : -spreadValue * 0.5,
                  side === "left" ? curlValue * 0.3 : -curlValue * 0.3
                );
                node.quaternion.slerp(
                  new THREE.Quaternion().setFromEuler(targetRot),
                  lerpAmount
                );
              } else {
                // Proximal, Distal: Êõ≤„Åí
                const targetRot = new THREE.Euler(
                  0,
                  0,
                  side === "left" ? curlValue * 0.4 : -curlValue * 0.4
                );
                node.quaternion.slerp(
                  new THREE.Quaternion().setFromEuler(targetRot),
                  lerpAmount
                );
              }
            } else {
              // ‰ªñ„ÅÆ4Êú¨Êåá: XËª∏ÂõûËª¢„ÅßÊõ≤„Åí„Çã
              const curlValue = fingerData.curl || 0;
              const targetRot = new THREE.Euler(curlValue * 0.9, 0, 0);
              node.quaternion.slerp(
                new THREE.Quaternion().setFromEuler(targetRot),
                lerpAmount
              );
            }
          });
        });
      }
      // --- 6. MediaPipe Results Handler ---
      holistic.onResults((results) => {
        if (!isAvatarMode) {
          // È™®Ê†ºË°®Á§∫„É¢„Éº„Éâ
          skelCtx.save();
          skelCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
          // „Éù„Éº„Ç∫Ôºà‰ΩìÔºâ
          drawConnectors(skelCtx, results.poseLandmarks, POSE_CONNECTIONS, {
            color: "#00FF00",
            lineWidth: 3,
          });
          drawLandmarks(skelCtx, results.poseLandmarks, {
            color: "#FF0000",
            lineWidth: 2,
            radius: 4,
          });
          // Â∑¶Êâã
          drawConnectors(skelCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {
            color: "#00CCFF",
            lineWidth: 3,
          });
          drawLandmarks(skelCtx, results.leftHandLandmarks, {
            color: "#0088FF",
            lineWidth: 1,
            radius: 3,
          });
          // Âè≥Êâã
          drawConnectors(
            skelCtx,
            results.rightHandLandmarks,
            HAND_CONNECTIONS,
            { color: "#FFCC00", lineWidth: 3 }
          );
          drawLandmarks(skelCtx, results.rightHandLandmarks, {
            color: "#FF8800",
            lineWidth: 1,
            radius: 3,
          });
          // È°î
          drawConnectors(skelCtx, results.faceLandmarks, FACEMESH_TESSELATION, {
            color: "#C0C0C070",
            lineWidth: 1,
          });
          skelCtx.restore();
        } else if (currentVrm) {
          // ========================================
          //  „Ç¢„Éê„Çø„Éº„É¢„Éº„Éâ - ÂÖ®Ë∫´„Éà„É©„ÉÉ„Ç≠„É≥„Ç∞
          // ========================================
          // --- È°î (Face) ---
          if (results.faceLandmarks) {
            const faceRig = Kalidokit.Face.solve(results.faceLandmarks, {
              runtime: "mediapipe",
              video: videoElement,
            });
            if (faceRig) {
              // È†≠„ÅÆÂõûËª¢
              const head = currentVrm.humanoid.getNormalizedBoneNode("head");
              const neck = currentVrm.humanoid.getNormalizedBoneNode("neck");
              if (head) {
                head.quaternion.slerp(
                  new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(
                      faceRig.head.x * 0.6,
                      faceRig.head.y * 0.6,
                      faceRig.head.z * 0.6
                    )
                  ),
                  0.4
                );
              }
              if (neck) {
                neck.quaternion.slerp(
                  new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(
                      faceRig.head.x * 0.4,
                      faceRig.head.y * 0.4,
                      faceRig.head.z * 0.4
                    )
                  ),
                  0.4
                );
              }
              // Ë°®ÊÉÖ
              if (currentVrm.expressionManager) {
                // Âè£
                currentVrm.expressionManager.setValue(
                  "aa",
                  faceRig.mouth.shape.A
                );
                currentVrm.expressionManager.setValue(
                  "ih",
                  faceRig.mouth.shape.I
                );
                currentVrm.expressionManager.setValue(
                  "ou",
                  faceRig.mouth.shape.U
                );
                currentVrm.expressionManager.setValue(
                  "ee",
                  faceRig.mouth.shape.E
                );
                currentVrm.expressionManager.setValue(
                  "oh",
                  faceRig.mouth.shape.O
                );
                // ÁõÆ
                currentVrm.expressionManager.setValue(
                  "blinkLeft",
                  1 - faceRig.eye.l
                );
                currentVrm.expressionManager.setValue(
                  "blinkRight",
                  1 - faceRig.eye.r
                );
                // Áû≥„ÅÆÂêë„ÅçÔºàÂØæÂøú„É¢„Éá„É´„ÅÆ„ÅøÔºâ
                if (faceRig.pupil) {
                  currentVrm.expressionManager.setValue(
                    "lookLeft",
                    faceRig.pupil.x < 0 ? -faceRig.pupil.x : 0
                  );
                  currentVrm.expressionManager.setValue(
                    "lookRight",
                    faceRig.pupil.x > 0 ? faceRig.pupil.x : 0
                  );
                  currentVrm.expressionManager.setValue(
                    "lookUp",
                    faceRig.pupil.y > 0 ? faceRig.pupil.y : 0
                  );
                  currentVrm.expressionManager.setValue(
                    "lookDown",
                    faceRig.pupil.y < 0 ? -faceRig.pupil.y : 0
                  );
                }
              }
            }
          }
          // --- ‰Ωì (Body) ---
          if (results.poseLandmarks) {
            // poseWorldLandmarks„Åå„Å™„ÅÑÂ†¥Âêà„ÅØposeLandmarks„Çí‰∏°Êñπ„Å´‰ΩøÁî®
            const worldLandmarks = results.poseWorldLandmarks || results.poseLandmarks;
            
            const poseRig = Kalidokit.Pose.solve(
              results.poseLandmarks,
              worldLandmarks,
              {
                runtime: "mediapipe",
                video: videoElement,
              }
            );
            // „Éá„Éê„ÉÉ„Ç∞: poseRig„ÅÆÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç
            if (poseRig && Math.random() < 0.02) {
              console.log("poseRig:", poseRig);
            }
            if (poseRig) {
              const rigRotation = (name, rot, lerpAmount = 0.5) => {
                const node = currentVrm.humanoid.getNormalizedBoneNode(name);
                if (node && rot) {
                  const targetQuat = new THREE.Quaternion().setFromEuler(
                    new THREE.Euler(rot.x, rot.y, rot.z)
                  );
                  node.quaternion.slerp(targetQuat, lerpAmount);
                }
              };
              // ‰ΩìÂππ
              if (poseRig.Hips?.rotation) rigRotation("hips", poseRig.Hips.rotation);
              if (poseRig.Spine) rigRotation("spine", poseRig.Spine);
              if (poseRig.Chest) rigRotation("chest", poseRig.Chest);
              // ËÖïÔºà„Çà„ÇäÂ§ß„Åç„Å™Ë£úÈñì‰øÇÊï∞„ÅßÂèçÂøú„ÇíÈÄü„ÅèÔºâ
              rigRotation("rightUpperArm", poseRig.RightUpperArm, 0.6);
              rigRotation("leftUpperArm", poseRig.LeftUpperArm, 0.6);
              rigRotation("rightLowerArm", poseRig.RightLowerArm, 0.6);
              rigRotation("leftLowerArm", poseRig.LeftLowerArm, 0.6);
              // ÊâãÈ¶ñ
              rigRotation("rightHand", poseRig.RightHand);
              rigRotation("leftHand", poseRig.LeftHand);
              // Ë∂≥
              rigRotation("rightUpperLeg", poseRig.RightUpperLeg);
              rigRotation("leftUpperLeg", poseRig.LeftUpperLeg);
              rigRotation("rightLowerLeg", poseRig.RightLowerLeg);
              rigRotation("leftLowerLeg", poseRig.LeftLowerLeg);
            }
          }
          // --- Â∑¶Êâã„ÅÆÊåá (Left Hand) ---
          if (results.leftHandLandmarks) {
            const leftHandRig = Kalidokit.Hand.solve(
              results.leftHandLandmarks,
              "Left"
            );
            applyFingerRig(leftHandRig, "left");
          }
          // --- Âè≥Êâã„ÅÆÊåá (Right Hand) ---
          if (results.rightHandLandmarks) {
            const rightHandRig = Kalidokit.Hand.solve(
              results.rightHandLandmarks,
              "Right"
            );
            applyFingerRig(rightHandRig, "right");
          }
          // VRMÊõ¥Êñ∞„Å®„É¨„É≥„ÉÄ„É™„É≥„Ç∞
          currentVrm.update(1.0 / 30.0);
          renderer.render(scene, camera);
        }
      });
      // --- 7. Camera Start ---
      window.onload = () => {
        new Camera(videoElement, {
          onFrame: async () => await holistic.send({ image: videoElement }),
          width: 640,
          height: 480,
        })
          .start()
          .then(() => {
            console.log("Camera started successfully");
          })
          .catch((err) => {
            console.error("Camera start error:", err);
            stVrm.innerText = "Camera Error";
            stVrm.style.color = "red";
          });
      };
    </script>
  </body>
</html>
