<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTuber Manual Control</title>
    <style>
        body { margin: 0; background-color: #222; overflow: hidden; font-family: monospace; }
        .container { position: relative; width: 100vw; height: 100vh; }
        
        /* 映像は位置合わせ用にうっすら残す(10%) */
        video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; z-index: 0; transition: opacity 0.5s; opacity: 1; }
        
        canvas#skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); z-index: 1; pointer-events: none; }
        
        /* 操作説明パネル */
        #controls {
            position: absolute; top: 10px; right: 10px; width: 220px;
            background: rgba(0, 0, 0, 0.7); color: #fff; padding: 15px;
            border-radius: 8px; z-index: 1000; font-size: 12px; pointer-events: none;
            line-height: 1.6; border: 1px solid #444;
        }
        .key { display: inline-block; background: #555; padding: 2px 6px; border-radius: 4px; font-weight: bold; color: #fff; }
        
        /* ステータス */
        #status-panel {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0, 0, 0, 0.7); color: #fff; padding: 5px 10px;
            border-radius: 8px; z-index: 1000; font-size: 12px;
        }
        .ok { color: #00ff00; } .ng { color: #ff3333; }

        #toggle-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            color: #888; background: #333; border: 2px solid #555; border-radius: 50px; 
            cursor: not-allowed; z-index: 100; transition: all 0.3s;
        }
        #toggle-btn.ready {
            color: #fff; background: linear-gradient(45deg, #ff00cc, #3333ff);
            border: none; cursor: pointer; box-shadow: 0 0 20px rgba(255, 0, 204, 0.6);
        }
    </style>
</head>
<body>
    <div id="status-panel">VRM: <span id="st-vrm" class="ng">Loading...</span> | Face: <span id="st-face" class="ng">Wait</span></div>

    <!-- 操作説明 -->
    <div id="controls">
        <strong>Camera Controls:</strong><br>
        <span class="key">↑</span> <span class="key">↓</span> : Up / Down<br>
        <span class="key">←</span> <span class="key">→</span> : Left / Right<br>
        <span class="key">W</span> : Zoom In<br>
        <span class="key">S</span> : Zoom Out<br>
        <span class="key">R</span> : Reset Pos
    </div>

    <div class="container">
        <video id="input-video" playsinline muted autoplay></video>
        <canvas id="skeleton-canvas"></canvas>
    </div>

    <button id="toggle-btn" disabled>Loading Model...</button>

    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/@pixiv/three-vrm@1.0.0/lib/three-vrm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>

    <script>
        const videoElement = document.getElementById('input-video');
        const skeletonCanvas = document.getElementById('skeleton-canvas');
        const skelCtx = skeletonCanvas.getContext('2d');
        const toggleBtn = document.getElementById('toggle-btn');
        const stVrm = document.getElementById('st-vrm');
        const stFace = document.getElementById('st-face');

        const VRM_FILE_PATH = './avatar.vrm';
        let currentVrm = null;
        let isAvatarMode = false;

        // --- 1. Three.js Setup ---
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.domElement.id = 'avatar-canvas';
        renderer.domElement.style.cssText = "position:absolute; top:0; left:0; width:100%; height:100%; z-index:2; display:none;";
        document.querySelector('.container').appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        
        // カメラ初期位置 (x, y, z)
        // y=1.3 (胸の高さ), z=2.2 (少し離れる)
        const initialCamPos = { x: 0.0, y: 1.3, z: 2.2 };
        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(initialCamPos.x, initialCamPos.y, initialCamPos.z);
        
        // ★目印用の黄色い箱（アバターの顔があるべき場所）
        // アバターが見えなくても、この箱が見えればカメラは合っている
        const marker = new THREE.Mesh(
            new THREE.BoxGeometry(0.1, 0.1, 0.1),
            new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true })
        );
        marker.position.set(0, 1.4, 0); // 高さ1.4mに配置
        scene.add(marker);

        scene.add(new THREE.DirectionalLight(0xffffff));
        scene.add(new THREE.AmbientLight(0x505050));

        // --- キーボード操作機能 ---
        window.addEventListener('keydown', (e) => {
            if(!isAvatarMode) return;
            const step = 0.1;
            switch(e.key) {
                case 'ArrowUp': camera.position.y += step; break;
                case 'ArrowDown': camera.position.y -= step; break;
                case 'ArrowLeft': camera.position.x -= step; break;
                case 'ArrowRight': camera.position.x += step; break;
                case 'w': case 'W': camera.position.z -= step; break; // ズームイン
                case 's': case 'S': camera.position.z += step; break; // ズームアウト
                case 'r': case 'R': camera.position.set(initialCamPos.x, initialCamPos.y, initialCamPos.z); break;
            }
            // 常にマーカー（中心）の方を向く
            camera.lookAt(0, 1.2, 0); 
        });

        function resize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            skeletonCanvas.width = window.innerWidth;
            skeletonCanvas.height = window.innerHeight;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resize);
        resize();

        // --- 2. VRM Load (自動調整なしの素の状態) ---
        new THREE.GLTFLoader().register(p => new THREE_VRM.VRMLoaderPlugin(p)).load(
            VRM_FILE_PATH,
            (gltf) => {
                currentVrm = gltf.userData.vrm;
                scene.add(currentVrm.scene);
                currentVrm.scene.rotation.y = Math.PI;
                
                // ★位置は固定（0,0,0）
                currentVrm.scene.position.set(0, 0, 0);

                // Tポーズ補正
                const h = currentVrm.humanoid;
                if(h.getNormalizedBoneNode('leftUpperArm')) h.getNormalizedBoneNode('leftUpperArm').rotation.z = 1.2;
                if(h.getNormalizedBoneNode('rightUpperArm')) h.getNormalizedBoneNode('rightUpperArm').rotation.z = -1.2;

                stVrm.innerText = "OK (Ready)";
                stVrm.className = "ok";
                toggleBtn.disabled = false;
                toggleBtn.classList.add('ready');
                toggleBtn.innerText = "START VTUBER";
            },
            undefined,
            (e) => { stVrm.innerText = "Error"; stVrm.className = "ng"; }
        );

        // --- 3. Toggle ---
        toggleBtn.addEventListener('click', () => {
            if(!currentVrm) return;
            isAvatarMode = !isAvatarMode;
            const avatarCanvas = document.getElementById('avatar-canvas');

            if(isAvatarMode) {
                avatarCanvas.style.display = 'block';
                skeletonCanvas.style.display = 'none';
                videoElement.style.opacity = "0.1"; // 10%だけ残す（位置合わせ用）
                toggleBtn.innerText = "STOP";
                toggleBtn.style.opacity = "0.5";
                
                // 起動時にカメラの向きを再調整
                camera.lookAt(0, 1.2, 0); 
            } else {
                avatarCanvas.style.display = 'none';
                skeletonCanvas.style.display = 'block';
                videoElement.style.opacity = "1";
                toggleBtn.innerText = "START VTUBER";
                toggleBtn.style.opacity = "1";
            }
        });

        // --- 4. AI Loop ---
        const holistic = new Holistic({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${f}`});
        holistic.setOptions({ modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7, refineFaceLandmarks: true });

        holistic.onResults((results) => {
            if(results.faceLandmarks) { stFace.innerText = "OK"; stFace.className = "ok"; } 
            else { stFace.innerText = "Wait"; stFace.className = "ng"; }

            if(!isAvatarMode) {
                skelCtx.save();
                skelCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
                drawConnectors(skelCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                drawLandmarks(skelCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2, radius: 5});
                skelCtx.restore();
            } else if(currentVrm) {
                // 顔
                if (results.faceLandmarks) {
                    const faceRig = Kalidokit.Face.solve(results.faceLandmarks, {runtime: 'mediapipe', video: videoElement});
                    if (faceRig) {
                        const neck = currentVrm.humanoid.getNormalizedBoneNode("neck");
                        if (neck) neck.quaternion.slerp(new THREE.Quaternion().setFromEuler(new THREE.Euler(faceRig.head.x, faceRig.head.y, faceRig.head.z)), 0.5);
                        if(currentVrm.expressionManager){
                            currentVrm.expressionManager.setValue('aa', faceRig.mouth.shape.A);
                            currentVrm.expressionManager.setValue('blinkLeft', 1 - faceRig.eye.l);
                            currentVrm.expressionManager.setValue('blinkRight', 1 - faceRig.eye.r);
                        }
                    }
                }
                // 体
                if (results.poseLandmarks && results.poseWorldLandmarks) {
                    const poseRig = Kalidokit.Pose.solve(results.poseLandmarks, results.poseWorldLandmarks, {runtime: 'mediapipe', video: videoElement});
                    if (poseRig) {
                        const rig = (name, rot) => {
                            const node = currentVrm.humanoid.getNormalizedBoneNode(name);
                            if(node && rot) node.quaternion.slerp(new THREE.Quaternion().setFromEuler(new THREE.Euler(rot.x, rot.y, rot.z)), 0.3);
                        };
                        rig("hips", poseRig.Hips.rotation);
                        rig("spine", poseRig.Spine);
                        rig("rightUpperArm", poseRig.RightUpperArm);
                        rig("leftUpperArm", poseRig.LeftUpperArm);
                        rig("rightLowerArm", poseRig.RightLowerArm);
                        rig("leftLowerArm", poseRig.LeftLowerArm);
                        rig("rightUpperLeg", poseRig.RightUpperLeg);
                        rig("leftUpperLeg", poseRig.LeftUpperLeg);
                        rig("rightLowerLeg", poseRig.RightLowerLeg);
                        rig("leftLowerLeg", poseRig.LeftLowerLeg);
                    }
                }
                currentVrm.update(1.0/30.0);
                
                // ★箱（マーカー）を回す
                marker.rotation.y += 0.05;
                
                renderer.render(scene, camera);
            }
        });

        window.onload = () => {
            new Camera(videoElement, {
                onFrame: async () => await holistic.send({image: videoElement}),
                width: 640, height: 480
            }).start();
        };
    </script>
</body>
</html>
