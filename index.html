<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skeleton & Avatar Fix</title>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; font-family: sans-serif; }
        
        .container { position: relative; width: 100vw; height: 100vh; }

        /* カメラ映像 */
        #input-video {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform: scaleX(-1); object-fit: cover; z-index: 0;
        }

        /* 骨格 (2D) */
        #skeleton-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            transform: scaleX(-1); z-index: 1; pointer-events: none;
        }

        /* アバター (3D) - 初期は非表示 */
        #avatar-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
            display: none; 
        }

        /* ボタン */
        #toggle-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            color: #fff; background: linear-gradient(45deg, #ff00cc, #3333ff);
            border: none; border-radius: 50px; cursor: pointer; z-index: 100;
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.5);
        }
        #toggle-btn:active { transform: translateX(-50%) scale(0.95); }

        /* ログ */
        #log-container {
            position: absolute; top: 10px; left: 10px; color: #0f0; 
            background: rgba(0,0,0,0.5); padding: 5px; z-index: 100; font-family: monospace;
        }
    </style>
</head>
<body>

    <div class="container">
        <video id="input-video" playsinline muted autoplay></video>
        <canvas id="skeleton-canvas"></canvas>
    </div>

    <button id="toggle-btn">スキン装着 (Transform)</button>
    <div id="log-container">System Starting...</div>

    <!-- ライブラリ読み込み (URLを修正済み) -->
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/@pixiv/three-vrm@1.0.0/lib/three-vrm.min.js"></script>
    
    <!-- ここが修正箇所！バージョン指定を外して最新版を取得するように変更 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>

    <script>
        const logDiv = document.getElementById('log-container');
        const skeletonCanvas = document.getElementById('skeleton-canvas');
        const skelCtx = skeletonCanvas.getContext('2d');
        const videoElement = document.getElementById('input-video');
        const toggleBtn = document.getElementById('toggle-btn');
        const VRM_FILE_PATH = './3453930163915015062.vrm';

        let isAvatarMode = false;
        let currentVrm = null;

        // リサイズ処理
        function resizeCanvas() {
            skeletonCanvas.width = window.innerWidth;
            skeletonCanvas.height = window.innerHeight;
            if(renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // --- Three.js 設定 ---
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.domElement.id = 'avatar-canvas';
        document.querySelector('.container').appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.3, 4.5);

        const light = new THREE.DirectionalLight(0xffffff);
        light.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- VRM読み込み ---
        const loader = new THREE.GLTFLoader();
        loader.register((parser) => new THREE_VRM.VRMLoaderPlugin(parser));

        loader.load(VRM_FILE_PATH, (gltf) => {
            const vrm = gltf.userData.vrm;
            currentVrm = vrm;
            scene.add(vrm.scene);
            vrm.scene.rotation.y = Math.PI;
            
            const leftArm = vrm.humanoid.getNormalizedBoneNode('leftUpperArm');
            const rightArm = vrm.humanoid.getNormalizedBoneNode('rightUpperArm');
            if(leftArm) leftArm.rotation.z = 1.2;
            if(rightArm) rightArm.rotation.z = -1.2;

            logDiv.innerText = "VRM Ready! Waiting for Camera...";
        }, undefined, (err) => logDiv.innerText = "VRM Error: " + err);


        // --- ボタン切り替え ---
        toggleBtn.addEventListener('click', () => {
            isAvatarMode = !isAvatarMode;

            if (isAvatarMode) {
                toggleBtn.innerText = "骨格に戻る (Skeleton)";
                toggleBtn.style.background = "#333";
                document.getElementById('avatar-canvas').style.display = 'block';
                skeletonCanvas.style.display = 'none';
                videoElement.style.opacity = "0.3"; 
            } else {
                toggleBtn.innerText = "スキン装着 (Transform)";
                toggleBtn.style.background = "linear-gradient(45deg, #ff00cc, #3333ff)";
                document.getElementById('avatar-canvas').style.display = 'none';
                skeletonCanvas.style.display = 'block';
                videoElement.style.opacity = "1.0";
            }
        });


        // --- MediaPipe 設定 ---
        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7,
            refineFaceLandmarks: true
        });
        holistic.onResults(onResults);


        // --- メインループ ---
        function onResults(results) {
            logDiv.innerText = "Tracking Active"; // 動作確認用

            if (!isAvatarMode) {
                // 骨格モード
                skelCtx.save();
                skelCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
                drawConnectors(skelCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                drawLandmarks(skelCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2, radius: 5});
                drawConnectors(skelCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#CC0000', lineWidth: 3});
                drawConnectors(skelCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00CC00', lineWidth: 3});
                skelCtx.restore();
            } else {
                // アバターモード
                if (currentVrm) {
                    animateVRM(results);
                    renderer.render(scene, camera);
                }
            }
        }

        // --- アバター計算 ---
        function animateVRM(results) {
            if (!results.poseLandmarks || !results.poseWorldLandmarks) return;

            const rigidPose = Kalidokit.Pose.solve(results.poseLandmarks, results.poseWorldLandmarks, {runtime: 'mediapipe', video: videoElement});
            const rigidFace = Kalidokit.Face.solve(results.faceLandmarks, {runtime: 'mediapipe', video: videoElement});
            const rigidLeft = results.leftHandLandmarks ? Kalidokit.Hand.solve(results.leftHandLandmarks, "Left") : null;
            const rigidRight = results.rightHandLandmarks ? Kalidokit.Hand.solve(results.rightHandLandmarks, "Right") : null;

            const rigRotation = (name, rotation, dampener = 1, lerpAmount = 0.3) => {
                if (!rotation) return;
                const part = currentVrm.humanoid.getNormalizedBoneNode(name);
                if (!part) return;
                const euler = new THREE.Euler(rotation.x * dampener, rotation.y * dampener, rotation.z * dampener);
                const quaternion = new THREE.Quaternion().setFromEuler(euler);
                part.quaternion.slerp(quaternion, lerpAmount);
            };

            if (rigidPose) {
                rigRotation("hips", rigidPose.Hips.rotation, 0.7);
                rigRotation("chest", rigidPose.Spine, 0.25);
                rigRotation("spine", rigidPose.Spine, 0.45);
                rigRotation("rightUpperArm", rigidPose.RightUpperArm, 1);
                rigRotation("rightLowerArm", rigidPose.RightLowerArm, 1);
                rigRotation("leftUpperArm", rigidPose.LeftUpperArm, 1);
                rigRotation("leftLowerArm", rigidPose.LeftLowerArm, 1);
            }
            if (rigidLeft) rigRotation("leftHand", rigidLeft.LeftWrist);
            if (rigidRight) rigRotation("rightHand", rigidRight.RightWrist);
            if (rigidFace) {
                rigRotation("neck", rigidFace.head, 0.7);
                if(currentVrm.expressionManager){
                    currentVrm.expressionManager.setValue('aa', rigidFace.mouth.shape.A);
                    currentVrm.expressionManager.setValue('blinkLeft', 1 - rigidFace.eye.l);
                    currentVrm.expressionManager.setValue('blinkRight', 1 - rigidFace.eye.r);
                }
            }
            currentVrm.update(1.0 / 30.0);
        }

        // --- カメラ起動（ここがエラーの原因だった箇所） ---
        // 修正：Cameraクラスが読み込まれているかチェック
        if (typeof Camera !== 'undefined') {
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await holistic.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        } else {
            logDiv.innerText = "ERROR: Camera Library Failed to Load.";
            logDiv.style.color = "red";
        }

    </script>
</body>
</html>
