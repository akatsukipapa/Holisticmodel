<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VTuber Diagnostic</title>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; font-family: monospace; }
        .container { position: relative; width: 100vw; height: 100vh; }
        video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; z-index: 0; }
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
        #avatar-canvas { z-index: 2; display: none; }
        #skeleton-canvas { z-index: 1; transform: scaleX(-1); }
        
        /* 診断パネル */
        #status-panel {
            position: absolute; top: 10px; left: 10px; width: 300px;
            background: rgba(0, 0, 0, 0.8); color: #fff; padding: 10px;
            border-radius: 8px; z-index: 1000; font-size: 12px; border: 1px solid #555;
        }
        .status-item { margin-bottom: 5px; border-bottom: 1px solid #444; padding-bottom: 2px; }
        .ok { color: #00ff00; font-weight: bold; }
        .ng { color: #ff0000; font-weight: bold; }
        .warn { color: #ffff00; font-weight: bold; }

        #toggle-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            color: #888; background: #333; border: 2px solid #555; border-radius: 50px; 
            cursor: not-allowed; z-index: 100;
        }
        #toggle-btn.ready {
            color: #fff; background: linear-gradient(45deg, #ff00cc, #3333ff);
            border: none; cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="status-panel">
        <div class="status-item">System: <span id="st-system">Init...</span></div>
        <div class="status-item">VRM Model: <span id="st-vrm" class="warn">Loading...</span></div>
        <div class="status-item">MediaPipe AI: <span id="st-ai" class="ng">Waiting...</span></div>
        <div class="status-item">Pose Data: <span id="st-pose" class="ng">No Data</span></div>
        <div class="status-item">Calc(Kalidokit): <span id="st-calc" class="ng">Stopped</span></div>
    </div>

    <div class="container">
        <video id="input-video" playsinline muted autoplay></video>
        <canvas id="skeleton-canvas"></canvas>
    </div>

    <button id="toggle-btn" disabled>Loading...</button>

    <!-- ライブラリ -->
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/@pixiv/three-vrm@1.0.0/lib/three-vrm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>

    <script>
        const videoElement = document.getElementById('input-video');
        const skeletonCanvas = document.getElementById('skeleton-canvas');
        const skelCtx = skeletonCanvas.getContext('2d');
        const toggleBtn = document.getElementById('toggle-btn');
        
        // ステータス表示用
        const stSystem = document.getElementById('st-system');
        const stVrm = document.getElementById('st-vrm');
        const stAi = document.getElementById('st-ai');
        const stPose = document.getElementById('st-pose');
        const stCalc = document.getElementById('st-calc');

        const VRM_FILE_PATH = './avatar.vrm';
        let currentVrm = null;
        let isAvatarMode = false;

        // 1. Three.js Setup
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.domElement.id = 'avatar-canvas';
        document.querySelector('.container').appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.4, 1.5); // ★カメラを少し近づけました
        
        scene.add(new THREE.DirectionalLight(0xffffff));
        scene.add(new THREE.AmbientLight(0x404040));

        // テスト用Box
        const testCube = new THREE.Mesh(new THREE.BoxGeometry(0.2,0.2,0.2), new THREE.MeshBasicMaterial({color:0xff0000}));
        testCube.position.set(0.8, 1.5, 0);
        scene.add(testCube);

        function resize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            skeletonCanvas.width = window.innerWidth;
            skeletonCanvas.height = window.innerHeight;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resize);
        resize();

        // 2. VRM Load
        new THREE.GLTFLoader().register(p => new THREE_VRM.VRMLoaderPlugin(p)).load(
            VRM_FILE_PATH,
            (gltf) => {
                currentVrm = gltf.userData.vrm;
                scene.add(currentVrm.scene);
                currentVrm.scene.rotation.y = Math.PI;
                
                // 初期ポーズ
                const h = currentVrm.humanoid;
                if(h.getNormalizedBoneNode('leftUpperArm')) h.getNormalizedBoneNode('leftUpperArm').rotation.z = 1.2;
                if(h.getNormalizedBoneNode('rightUpperArm')) h.getNormalizedBoneNode('rightUpperArm').rotation.z = -1.2;

                stVrm.innerText = "OK (Loaded)";
                stVrm.className = "ok";
                toggleBtn.disabled = false;
                toggleBtn.classList.add('ready');
                toggleBtn.innerText = "スキン装着 (Start)";
            },
            undefined,
            (e) => {
                stVrm.innerText = "Error: " + e;
                stVrm.className = "ng";
            }
        );

        // 3. Toggle
        toggleBtn.addEventListener('click', () => {
            if(!currentVrm) return;
            isAvatarMode = !isAvatarMode;
            if(isAvatarMode) {
                document.getElementById('avatar-canvas').style.display = 'block';
                skeletonCanvas.style.display = 'none';
                videoElement.style.opacity = "0.2";
                toggleBtn.innerText = "骨格に戻る";
            } else {
                document.getElementById('avatar-canvas').style.display = 'none';
                skeletonCanvas.style.display = 'block';
                videoElement.style.opacity = "1.0";
                toggleBtn.innerText = "スキン装着";
            }
        });

        // 4. MediaPipe
        const holistic = new Holistic({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${f}`});
        holistic.setOptions({
            modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7
        });

        holistic.onResults((results) => {
            stSystem.innerText = "Running";
            stAi.innerText = "OK (Receiving)";
            stAi.className = "ok";

            // 骨格モード
            if(!isAvatarMode) {
                skelCtx.save();
                skelCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
                drawConnectors(skelCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                drawLandmarks(skelCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2, radius: 5});
                skelCtx.restore();
            } else {
                // アバターモード
                testCube.rotation.x += 0.05; // 箱回転
                
                // データチェック
                if(results.poseLandmarks) {
                    stPose.innerText = "OK (Landmarks Found)";
                    stPose.className = "ok";
                    
                    // Kalidokit計算
                    // poseWorldLandmarksが無い場合はposeLandmarksで代用（フォールバック）
                    const lm3d = results.poseWorldLandmarks || results.poseLandmarks; 

                    let pose = null;
                    try {
                        pose = Kalidokit.Pose.solve(lm3d, results.poseLandmarks, {runtime: 'mediapipe', video: videoElement});
                    } catch(e) {
                        console.error(e);
                    }

                    if(pose) {
                        stCalc.innerText = "OK (Solving)";
                        stCalc.className = "ok";
                        
                        // 反映
                        const rig = (name, rot) => {
                            if(!rot) return;
                            const node = currentVrm.humanoid.getNormalizedBoneNode(name);
                            if(node) {
                                node.quaternion.slerp(new THREE.Quaternion().setFromEuler(new THREE.Euler(rot.x, rot.y, rot.z)), 0.3);
                            }
                        };
                        
                        rig("hips", pose.Hips.rotation);
                        rig("spine", pose.Spine);
                        rig("chest", pose.Spine);
                        rig("rightUpperArm", pose.RightUpperArm);
                        rig("rightLowerArm", pose.RightLowerArm);
                        rig("leftUpperArm", pose.LeftUpperArm);
                        rig("leftLowerArm", pose.LeftLowerArm);

                        // 顔と手も
                        const face = Kalidokit.Face.solve(results.faceLandmarks, {runtime: 'mediapipe'});
                        if(face) rig("neck", face.head);
                        
                    } else {
                        stCalc.innerText = "NG (No Solution)";
                        stCalc.className = "ng";
                    }
                    currentVrm.update(1.0/30.0);
                    renderer.render(scene, camera);

                } else {
                    stPose.innerText = "NG (Body Not Found)";
                    stPose.className = "ng";
                }
            }
        });

        // 5. Start
        window.onload = () => {
            new Camera(videoElement, {
                onFrame: async () => await holistic.send({image: videoElement}),
                width: 640, height: 480
            }).start();
        };
    </script>
</body>
</html>
