<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed VTuber System</title>
    <style>
        body { margin: 0; background-color: #111; overflow: hidden; font-family: monospace; }
        .container { position: relative; width: 100vw; height: 100vh; }
        video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); object-fit: cover; z-index: 0; }
        canvas#skeleton-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; transform: scaleX(-1); z-index: 1; pointer-events: none; }
        canvas#avatar-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; display: none; }
        
        #toggle-btn {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            padding: 15px 40px; font-size: 1.5rem; font-weight: bold;
            color: #fff; background: linear-gradient(45deg, #ff00cc, #3333ff);
            border: none; border-radius: 50px; cursor: pointer; z-index: 100;
        }
        #log { position: absolute; top: 10px; left: 10px; color: #0f0; background: rgba(0,0,0,0.5); padding: 5px; z-index: 100; }
    </style>
</head>
<body>
    <div class="container">
        <video id="input-video" playsinline muted autoplay></video>
        <canvas id="skeleton-canvas"></canvas>
    </div>
    <button id="toggle-btn">スキン装着 (Transform)</button>
    <div id="log">Initializing...</div>

    <!-- ライブラリ -->
    <script src="https://unpkg.com/three@0.146.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/@pixiv/three-vrm@1.0.0/lib/three-vrm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/holistic/holistic.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/kalidokit@1.1.5/dist/kalidokit.umd.js"></script>

    <script>
        // DOM要素の取得
        const videoElement = document.getElementById('input-video');
        const skeletonCanvas = document.getElementById('skeleton-canvas');
        const skelCtx = skeletonCanvas.getContext('2d');
        const logDiv = document.getElementById('log');
        const toggleBtn = document.getElementById('toggle-btn');
        const VRM_FILE_PATH = './3453930163915015062.vrm';

        let currentVrm = null;
        let isAvatarMode = false;

        // --- 1. Three.js 初期化 (最優先) ---
        const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
        renderer.domElement.id = 'avatar-canvas';
        document.querySelector('.container').appendChild(renderer.domElement);
        
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(30.0, window.innerWidth / window.innerHeight, 0.1, 20.0);
        camera.position.set(0.0, 1.3, 4.5);
        
        const light = new THREE.DirectionalLight(0xffffff);
        light.position.set(1.0, 1.0, 1.0).normalize();
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // --- 2. リサイズ処理 (renderer定義後に定義) ---
        function resize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            skeletonCanvas.width = w;
            skeletonCanvas.height = h;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        }
        window.addEventListener('resize', resize);
        resize(); // 初回実行

        // --- 3. VRM読み込み ---
        const loader = new THREE.GLTFLoader();
        loader.register((parser) => new THREE_VRM.VRMLoaderPlugin(parser));
        loader.load(VRM_FILE_PATH, (gltf) => {
            currentVrm = gltf.userData.vrm;
            scene.add(currentVrm.scene);
            currentVrm.scene.rotation.y = Math.PI;
            // Tポーズ補正
            const human = currentVrm.humanoid;
            if(human.getNormalizedBoneNode('leftUpperArm')) human.getNormalizedBoneNode('leftUpperArm').rotation.z = 1.2;
            if(human.getNormalizedBoneNode('rightUpperArm')) human.getNormalizedBoneNode('rightUpperArm').rotation.z = -1.2;
            logDiv.innerText = "VRM Loaded. Starting Camera...";
        }, undefined, (err) => logDiv.innerText = "VRM Error: " + err);

        // --- 4. ボタン操作 ---
        toggleBtn.addEventListener('click', () => {
            isAvatarMode = !isAvatarMode;
            if (isAvatarMode) {
                toggleBtn.innerText = "骨格に戻る";
                document.getElementById('avatar-canvas').style.display = 'block';
                skeletonCanvas.style.display = 'none';
                videoElement.style.opacity = "0.3";
            } else {
                toggleBtn.innerText = "スキン装着";
                document.getElementById('avatar-canvas').style.display = 'none';
                skeletonCanvas.style.display = 'block';
                videoElement.style.opacity = "1.0";
            }
        });

        // --- 5. MediaPipe & Kalidokit 処理 ---
        const holistic = new Holistic({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/holistic/${file}`});
        holistic.setOptions({
            modelComplexity: 1, smoothLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7, refineFaceLandmarks: true
        });

        holistic.onResults((results) => {
            logDiv.innerText = "System Running"; 
            
            // 骨格モード
            if (!isAvatarMode) {
                skelCtx.save();
                skelCtx.clearRect(0, 0, skeletonCanvas.width, skeletonCanvas.height);
                drawConnectors(skelCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: '#00FF00', lineWidth: 4});
                drawLandmarks(skelCtx, results.poseLandmarks, {color: '#FF0000', lineWidth: 2, radius: 5});
                drawConnectors(skelCtx, results.leftHandLandmarks, HAND_CONNECTIONS, {color: '#CC0000', lineWidth: 3});
                drawConnectors(skelCtx, results.rightHandLandmarks, HAND_CONNECTIONS, {color: '#00CC00', lineWidth: 3});
                skelCtx.restore();
                return;
            }

            // アバターモード (currentVrmロード済み かつ ポーズ検出時のみ)
            if (currentVrm && results.poseLandmarks && results.poseWorldLandmarks) {
                const rigRotation = (name, rot, damp = 1, lerp = 0.3) => {
                    if (!rot) return;
                    const node = currentVrm.humanoid.getNormalizedBoneNode(name);
                    if (!node) return;
                    const q = new THREE.Quaternion().setFromEuler(new THREE.Euler(rot.x * damp, rot.y * damp, rot.z * damp));
                    node.quaternion.slerp(q, lerp);
                };

                // Pose
                const pose = Kalidokit.Pose.solve(results.poseLandmarks, results.poseWorldLandmarks, {runtime: 'mediapipe', video: videoElement});
                if (pose) {
                    rigRotation("hips", pose.Hips.rotation, 0.7);
                    rigRotation("chest", pose.Spine, 0.25);
                    rigRotation("spine", pose.Spine, 0.45);
                    rigRotation("rightUpperArm", pose.RightUpperArm, 1);
                    rigRotation("rightLowerArm", pose.RightLowerArm, 1);
                    rigRotation("leftUpperArm", pose.LeftUpperArm, 1);
                    rigRotation("leftLowerArm", pose.LeftLowerArm, 1);
                }
                // Hands
                if (results.leftHandLandmarks) {
                    const lHand = Kalidokit.Hand.solve(results.leftHandLandmarks, "Left");
                    if(lHand) rigRotation("leftHand", lHand.LeftWrist);
                }
                if (results.rightHandLandmarks) {
                    const rHand = Kalidokit.Hand.solve(results.rightHandLandmarks, "Right");
                    if(rHand) rigRotation("rightHand", rHand.RightWrist);
                }
                // Face
                if (results.faceLandmarks) {
                    const face = Kalidokit.Face.solve(results.faceLandmarks, {runtime: 'mediapipe', video: videoElement});
                    if (face) {
                        rigRotation("neck", face.head, 0.7);
                        if(currentVrm.expressionManager) {
                            currentVrm.expressionManager.setValue('aa', face.mouth.shape.A);
                            currentVrm.expressionManager.setValue('blinkLeft', 1 - face.eye.l);
                            currentVrm.expressionManager.setValue('blinkRight', 1 - face.eye.r);
                        }
                    }
                }
                currentVrm.update(1.0 / 30.0);
                renderer.render(scene, camera);
            }
        });

        // --- 6. カメラ起動 (ウィンドウ読み込み完了後に実行) ---
        window.onload = function() {
            if (typeof Camera === 'undefined') {
                logDiv.innerText = "Error: Camera Library missing";
                return;
            }
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await holistic.send({image: videoElement}); },
                width: 640, height: 480
            });
            cameraUtils.start();
        };
    </script>
</body>
</html>
